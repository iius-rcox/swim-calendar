{
  "name": "Varsity Swim Schedule (Fixed Python v2)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours"
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Daily at 6 AM",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        144,
        432
      ]
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "https://docs.google.com/spreadsheets/d/1Knc2bbA3ISYssTBEPuUFG_AzTc2ABlmrnUdukTA4gTE/edit?gid=2043565434#gid=2043565434",
          "mode": "url"
        },
        "sheetName": {
          "__rl": true,
          "value": 2043565434,
          "mode": "list",
          "cachedResultName": "NRCA",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1Knc2bbA3ISYssTBEPuUFG_AzTc2ABlmrnUdukTA4gTE/edit#gid=2043565434"
        },
        "options": {}
      },
      "id": "google-sheets",
      "name": "Read Swim Schedule",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        368,
        336
      ],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "5meixr7yUUsgLl8A",
          "name": "Google Sheets account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "import re\nfrom datetime import datetime, timedelta\n\nitems = [item[\"json\"] for item in _input.all()]\n\nbase_year = datetime.now().year\ntoday = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)\n\n# Eastern Time offset hours from UTC\ndef get_eastern_offset_hours(dt):\n    \"\"\"Determine UTC offset: -4 for EDT, -5 for EST\"\"\"\n    year = dt.year\n    # DST starts 2nd Sunday in March\n    dst_start = datetime(year, 3, 8)\n    while dst_start.weekday() != 6:\n        dst_start += timedelta(days=1)\n    dst_start += timedelta(days=7)\n    \n    # DST ends 1st Sunday in November  \n    dst_end = datetime(year, 11, 1)\n    while dst_end.weekday() != 6:\n        dst_end += timedelta(days=1)\n    \n    if dst_start <= dt < dst_end:\n        return -4  # EDT\n    else:\n        return -5  # EST\n\nlocation_info = {\n    \"NRCA\": {\"name\": \"North Raleigh Christian Academy\", \"coords\": \"35.879750,-78.541972\"},\n    \"CSC\": {\"name\": \"Cary Swim Club\", \"coords\": \"35.774667,-78.769278\"},\n    \"OPT\": {\"name\": \"Optimist Aquatic Center\", \"coords\": \"35.862278,-78.643806\"},\n    \"Springdale\": {\"name\": \"Springdale\", \"coords\": \"35.896361,-78.723583\"}\n}\n\ndef parse_time_range(text):\n    m = re.search(r\"(\\d{1,2}:\\d{2})\\s*[-â€“]\\s*(\\d{1,2}:\\d{2})\", text)\n    if not m:\n        return None, None\n    start_str, end_str = m.groups()\n    def to_24h(t, am=False, pm=False):\n        h, m = map(int, t.split(\":\"))\n        if pm and h < 12:\n            h += 12\n        elif not am and not pm and 5 <= h < 12:\n            h += 12\n        return h, m\n    up = text.upper()\n    is_am = \"AM\" in up\n    is_pm = \"PM\" in up\n    return to_24h(start_str, is_am, is_pm), to_24h(end_str, is_am, is_pm)\n\ndef parse_event_location(text):\n    up = text.upper()\n    if \"CSC\" in up:\n        key = \"CSC\"\n    elif \"OPT\" in up or \"OPTIMIST\" in up:\n        key = \"OPT\"\n    elif \"SPRINGDALE\" in up:\n        key = \"Springdale\"\n    else:\n        key = \"NRCA\"\n    return key, location_info[key]\n\ndef extract_week_date(header_text):\n    m = re.search(r\"(\\d{1,2})/(\\d{1,2})\", header_text)\n    if not m:\n        return None\n    month, day = map(int, m.groups())\n    week_date = datetime(base_year, month, day)\n    if week_date < today and today.month == 12 and month <= 2:\n        week_date = datetime(base_year + 1, month, day)\n    return week_date\n\nevents = []\ncurrent_week_start = None\nday_columns = [\"col_2\", \"col_3\", \"col_4\", \"col_5\", \"col_6\", \"col_7\"]\nday_names = [\"Mon\", \"Tue\", \"Wed\", \"Thur\", \"Fri\", \"Sat\"]\n\nif items:\n    first = items[0]\n    for key in list(first.keys()):\n        if (\"Week\" in key) and (\"/\" in key):\n            current_week_start = extract_week_date(key)\n            break\n\nfor row in items:\n    week_label = (row.get(\"Week 10/20\") or \"\").strip()\n    if \"Week of\" in week_label:\n        current_week_start = extract_week_date(week_label)\n        continue\n    if (not current_week_start) or (not week_label):\n        continue\n    group_name = week_label.strip()\n    if group_name.lower() != \"varsity\":\n        continue\n\n    for i, col in enumerate(day_columns):\n        text = (row.get(col) or \"\").strip()\n        if not text:\n            continue\n        if any(k in text.lower() for k in ['no practice', 'nrca closed', 'fall break', 'high school']):\n            continue\n        event_date = current_week_start + timedelta(days=i)\n        if event_date < today:\n            continue\n        date_str = event_date.strftime('%Y-%m-%d')\n        start_hm, end_hm = parse_time_range(text)\n        if not start_hm or not end_hm:\n            continue\n        sh, sm = start_hm\n        eh, em = end_hm\n        \n        # Create Eastern time and convert to UTC\n        local_start = datetime(event_date.year, event_date.month, event_date.day, sh, sm)\n        local_end = datetime(event_date.year, event_date.month, event_date.day, eh, em)\n        \n        offset = get_eastern_offset_hours(local_start)\n        utc_start = local_start - timedelta(hours=offset)\n        utc_end = local_end - timedelta(hours=offset)\n        \n        loc_key, loc = parse_event_location(text)\n        if \"meet\" in text.lower():\n            summary = \"Varsity Swim Meet\"\n            if loc_key != \"NRCA\":\n                summary += \" @ \" + loc_key\n        else:\n            summary = \"Varsity Swim Practice\"\n            if loc_key != \"NRCA\":\n                summary += \" @ \" + loc_key\n        unique_id = \"varsity-swim-\" + date_str + \"-\" + (\"%02d%02d\" % (sh, sm))\n        description = (\n            text + \"\\n\\n\" +\n            \"Location: \" + loc['name'] + \"\\n\" +\n            \"Coordinates: \" + loc['coords'] + \"\\n\\n\" +\n            \"Automatically synced from swim schedule\"\n        )\n        events.append({\n            \"summary\": summary,\n            \"location\": loc['name'] + \" (\" + loc['coords'] + \")\",\n            \"locationName\": loc['name'],\n            \"description\": description,\n            \"startDateTime\": utc_start.strftime('%Y-%m-%dT%H:%M:%SZ'),\n            \"endDateTime\": utc_end.strftime('%Y-%m-%dT%H:%M:%SZ'),\n            \"date\": date_str,\n            \"dayName\": day_names[i],\n            \"originalText\": text,\n            \"uniqueId\": unique_id\n        })\n\nreturn [{\"json\": e} for e in events]"
      },
      "id": "parse-multiple-weeks",
      "name": "Parse All Upcoming Weeks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        592,
        336
      ]
    },
    {
      "parameters": {
        "jsCode": "// Get events from the Parse All Upcoming Weeks node\nconst events = $input.all();\n\n// If no events found, use default 90-day range\nif (!events || events.length === 0) {\n  const now = new Date();\n  const oneDayAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));\n  const threeMonths = new Date(now.getTime() + (90 * 24 * 60 * 60 * 1000));\n  \n  return [{\n    json: {\n      timeMin: oneDayAgo.toISOString(),\n      timeMax: threeMonths.toISOString(),\n      eventCount: 0\n    }\n  }];\n}\n\n// Find min and max dates from parsed events\nlet minDate = null;\nlet maxDate = null;\n\nfor (const event of events) {\n  const start = event.json.startDateTime;\n  if (start) {\n    const d = new Date(start);\n    if (!minDate || d < minDate) {\n      minDate = d;\n    }\n    if (!maxDate || d > maxDate) {\n      maxDate = d;\n    }\n  }\n}\n\n// Add 1-day buffer before and after\nif (minDate) {\n  minDate = new Date(minDate.getTime() - (24 * 60 * 60 * 1000));\n}\nif (maxDate) {\n  maxDate = new Date(maxDate.getTime() + (24 * 60 * 60 * 1000));\n}\n\n// Fallback to 90-day range if dates couldn't be determined\nif (!minDate || !maxDate) {\n  const now = new Date();\n  minDate = new Date(now.getTime() - (24 * 60 * 60 * 1000));\n  maxDate = new Date(now.getTime() + (90 * 24 * 60 * 60 * 1000));\n}\n\n// Return the date range for calendar query\nreturn [{\n  json: {\n    timeMin: minDate.toISOString(),\n    timeMax: maxDate.toISOString(),\n    eventCount: events.length,\n    minDate: minDate.toISOString(),\n    maxDate: maxDate.toISOString()\n  }\n}];"
      },
      "id": "calculate-date-range",
      "name": "Calculate Date Range",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        816,
        272
      ]
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "value": "9e1cd67ce3a6ec7b76e0e0d3d4edf82ce34cf3e4338949dd60563eed5f41232e@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "MOR Practices"
        },
        "returnAll": true,
        "timeMin": "={{ $json.timeMin }}",
        "timeMax": "={{ $json.timeMax }}",
        "options": {}
      },
      "id": "get-existing-events",
      "name": "Get Existing Calendar Events",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        1040,
        272
      ],
      "alwaysOutputData": true,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "qqa8Ornf7yz5dwAo",
          "name": "Roger's Google Calendar"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Helper functions\nfunction normalizeDateTime(dateTimeStr) {\n  if (!dateTimeStr) return '';\n  try {\n    return new Date(dateTimeStr).toISOString();\n  } catch (e) {\n    return dateTimeStr;\n  }\n}\n\nfunction extractDate(dateTimeStr) {\n  if (!dateTimeStr) return '';\n  const match = dateTimeStr.match(/(\\d{4}-\\d{2}-\\d{2})/);\n  return match ? match[1] : '';\n}\n\n// Get scheduled practices from Parse node\nconst scheduledPractices = $('Parse All Upcoming Weeks').all();\n\n// Get existing calendar events from current input\nconst inputItems = $input.all();\n\n// Check if calendar was empty (Ensure Output returned isEmpty flag)\nconst isCalendarEmpty = inputItems.length === 1 && inputItems[0].json.isEmpty === true;\n\nlet existingEvents = [];\nif (!isCalendarEmpty) {\n  existingEvents = inputItems;\n}\n\nconsole.log('Scheduled practices:', scheduledPractices.length);\nconsole.log('Calendar was empty:', isCalendarEmpty);\nconsole.log('Existing events from calendar:', existingEvents.length);\n\nconst results = [];\nlet skipCount = 0;\n\n// Process each scheduled practice\nfor (const practiceItem of scheduledPractices) {\n  const p = practiceItem.json || {};\n  \n  // Look for matching existing event (skip if calendar was empty)\n  let matchingEvent = null;\n  if (!isCalendarEmpty) {\n    for (const eventItem of existingEvents) {\n      const e = eventItem.json || {};\n      const eventStartDtStr = (e.start?.dateTime || e.start?.date);\n      \n      if (!eventStartDtStr) continue;\n      \n      // Extract date from calendar event (in local time)\n      const eventDate = extractDate(eventStartDtStr);\n      // Use the local date field from practice (not UTC startDateTime)\n      const practiceDate = p.date;\n      const hasVarsity = (e.summary || '').includes('Varsity Swim');\n      \n      // Match by date and event name\n      if (eventDate === practiceDate && hasVarsity) {\n        matchingEvent = e;\n        console.log('MATCH FOUND for', p.date, e.summary);\n        break;\n      }\n    }\n  }\n  \n  if (matchingEvent) {\n    // Event exists - check if it needs updating\n    const e = matchingEvent;\n    const currentStart = normalizeDateTime(e.start?.dateTime || e.start?.date);\n    const currentEnd = normalizeDateTime(e.end?.dateTime || e.end?.date);\n    const schedStart = normalizeDateTime(p.startDateTime);\n    const schedEnd = normalizeDateTime(p.endDateTime);\n    const currentSummary = e.summary || '';\n    const currentLocation = e.location || '';\n    const currentDescription = e.description || '';\n    \n    const needsUpdate = (\n      currentStart !== schedStart ||\n      currentEnd !== schedEnd ||\n      currentSummary !== p.summary ||\n      currentLocation !== p.location ||\n      currentDescription !== p.description\n    );\n    \n    if (needsUpdate) {\n      // Only output items that need update\n      const resultData = {\n        eventId: e.id,\n        ...p,\n        action: 'update'\n      };\n      results.push({ json: resultData });\n    } else {\n      // Skip items - don't output them at all\n      console.log('SKIP:', p.date, p.summary, '- no changes needed');\n      skipCount++;\n    }\n  } else {\n    // Event doesn't exist - create it\n    console.log('NO MATCH for', p.date, p.summary, '- marking for creation');\n    const resultData = {\n      ...p,\n      action: 'create'\n    };\n    results.push({ json: resultData });\n  }\n}\n\nconsole.log('Total items output:', results.length);\nconsole.log('Items skipped (not output):', skipCount);\nconsole.log('Actions breakdown:', results.reduce((acc, r) => {\n  acc[r.json.action] = (acc[r.json.action] || 0) + 1;\n  return acc;\n}, {}));\n\nreturn results;"
      },
      "id": "compare-and-decide",
      "name": "Compare & Decide Actions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1488,
        336
      ]
    },
    {
      "parameters": {
        "mode": "expression",
        "output": "={{ $json.action === 'create' ? 0 : 1 }}"
      },
      "id": "switch-action",
      "name": "Route by Action",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        1712,
        304
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "value": "9e1cd67ce3a6ec7b76e0e0d3d4edf82ce34cf3e4338949dd60563eed5f41232e@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "MOR Practices"
        },
        "start": "={{ $json.startDateTime }}",
        "end": "={{ $json.endDateTime }}",
        "additionalFields": {
          "description": "={{ $json.description }}",
          "location": "={{ $json.location }}",
          "summary": "={{ $json.summary }}"
        }
      },
      "id": "create-event",
      "name": "Create New Event",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        1936,
        240
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "qqa8Ornf7yz5dwAo",
          "name": "Roger's Google Calendar"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "operation": "update",
        "calendar": {
          "__rl": true,
          "value": "9e1cd67ce3a6ec7b76e0e0d3d4edf82ce34cf3e4338949dd60563eed5f41232e@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "MOR Practices"
        },
        "eventId": "={{ $json.eventId }}",
        "updateFields": {
          "description": "={{ $json.description }}",
          "end": "={{ $json.endDateTime }}",
          "location": "={{ $json.location }}",
          "start": "={{ $json.startDateTime }}",
          "summary": "={{ $json.summary }}"
        }
      },
      "id": "update-event",
      "name": "Update Existing Event",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        1936,
        432
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "qqa8Ornf7yz5dwAo",
          "name": "Roger's Google Calendar"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "path": "ebf7c41c-9c2d-4379-9f6d-160931e867cf",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        144,
        240
      ],
      "id": "8ecd06ba-31a9-434f-86b9-ca23d48385bd",
      "name": "Webhook",
      "webhookId": "ebf7c41c-9c2d-4379-9f6d-160931e867cf"
    },
    {
      "parameters": {
        "jsCode": "// ALWAYS execute this node and ensure data flows through\nconst items = $input.all();\n\n// If no calendar events found, return a single empty item\n// This ensures Compare & Decide always executes\nif (!items || items.length === 0) {\n  console.log('No calendar events found - returning empty item');\n  return [{ json: { isEmpty: true, events: [] } }];\n}\n\nconsole.log('Calendar events found:', items.length);\nreturn items;"
      },
      "id": "3e581ee7-8e48-4c68-9fed-12c3375e5164",
      "name": "Ensure Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1264,
        272
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Daily at 6 AM": {
      "main": [
        [
          {
            "node": "Read Swim Schedule",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Swim Schedule": {
      "main": [
        [
          {
            "node": "Parse All Upcoming Weeks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse All Upcoming Weeks": {
      "main": [
        [
          {
            "node": "Calculate Date Range",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Date Range": {
      "main": [
        [
          {
            "node": "Get Existing Calendar Events",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compare & Decide Actions": {
      "main": [
        [
          {
            "node": "Route by Action",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Action": {
      "main": [
        [
          {
            "node": "Create New Event",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Existing Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Existing Calendar Events": {
      "main": [
        [
          {
            "node": "Ensure Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "Read Swim Schedule",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure Output": {
      "main": [
        [
          {
            "node": "Compare & Decide Actions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {},
  "versionId": "6222cca6-a136-42d9-b139-3ca201a6229c",
  "meta": {
    "instanceId": "914a7f1f55c20172c837bb63035a4acdf266083f8c2dc8a3e267ceb92224fa43"
  },
  "id": "BI1eODQ55Fchar2v",
  "tags": []
}